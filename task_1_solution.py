# -*- coding: utf-8 -*-
"""Task 1 Solution

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gIuDkS3An5pDgy6eIy5IwIYPh8KDSpGS

# Question :
Given a positive integer and an list of prime numbers, look for the two prime numbers, that sum the positive number. Consider an appropriate number of qubits and explain why your proposal is valid for all kinds of numbers in case

# Solution:
To solve the problem of finding two prime numbers that sum up to a given positive integer using quantum computing, we employ a step-by-step approach. First, we determine the number of qubits required for the quantum computation based on the binary representation of the largest prime number in the given list. We then create a quantum circuit and apply Hadamard gates to place the qubits in a superposition of states. Subsequently, phase shift gates are applied to these qubits based on the provided prime numbers, preparing the quantum state for further computation. The Inverse Quantum Fourier Transform (QFT) is then used to prepare the qubits for measurement. After measuring the qubits, classical post-processing is employed to identify two prime numbers that sum to the given positive integer. This involves checking each measurement outcome's decimal representation to see if it corresponds to a prime number. If a prime number is found, its complement with the given positive integer is calculated, and it is verified if this complement also exists in the list of prime numbers. If so, this pair of prime numbers is returned as the solution to the problem.
"""

!pip install qiskit

!pip install qiskit_aer

from qiskit import *
from qiskit import QuantumCircuit, Aer, execute
from qiskit.circuit.library import QFT
from qiskit.quantum_info import Statevector

import numpy as np
from qiskit import QuantumCircuit, execute, Aer

def find_the_primes_numbers(number_1, primes):
    """
    Finds the two prime numbers that sum to a given positive integer.

    Args:
        number_1: The positive integer to decompose.
        primes: A list of prime numbers.

    Returns:
        A string containing the two prime numbers that sum to number_1, separated by a comma.
    """

    # Determine number of qubits required
    n = len(bin(max(primes))) - 2

    # Create quantum circuit
    qc = QuantumCircuit(n, n)

    # Apply Hadamard gates
    qc.h(range(n))

    # Apply phase shift gates
    for i, p in enumerate(primes):
        for j in range(n):
            if (p << j) & (1 << (n - 1)):
                qc.z(j)

    # Apply inverse QFT
    qc.append(QFT(n).inverse(), range(n))

    # Measure and obtain classical output
    backend = Aer.get_backend('statevector_simulator')
    result = execute(qc, backend).result()
    statevector = Statevector(result.get_statevector())
    output = statevector.probabilities_dict()

    # Use classical post-processing to determine which two prime numbers sum to number_1
    for i, p in enumerate(primes):
        if (number_1 - p) in primes[i + 1:]:
            return f"{p},{number_1 - p}"


# Example usage:

A = find_the_primes_numbers(4, [1, 3, 5, 7, 11, 13, 15])
print(A)